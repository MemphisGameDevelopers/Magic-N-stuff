//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Threading;
using System.Collections;
using System.Collections.Generic;

public class VoxelWorld : MonoBehaviour
{
		public GameObject regionPrefab;
		public int regionXZ = 32;
		public int regionY = 32;
		public int initialRegions = 5;
		private Dictionary<string, Region> regions;
		private LinkedList<Region> dirtyRegions;
		private VoxelModifyTerrain clientRenderer;
		public bool useDisk = false;
		
		void Start ()
		{
		
				//Start singleton managers
				WorldGeneration instance = WorldGeneration.Instance;
				
				Region.setWorld (this);
				regions = new Dictionary<string, Region> ();
//				for (int x = 0; x < initialRegions; x++) {
//						for (int y =0; y < initialRegions; y++) {
//								for (int z = 0; z < initialRegions; z++) {
//										createRegion (x, y, z, false);
//								}
//						}
//				}
				//Region centerRegion = getRegionAtIndex (1, 0, 1);
				Region centerRegion = createRegion (0, 0, 0, false);
				loadAllNeighbors (centerRegion, false);
				
				//Initialize Chunk Manager
				GameObject chunkManagerGO = GameObject.Find ("Chunk Manager") as GameObject;
				ChunkManager manager = chunkManagerGO.GetComponent<ChunkManager> ();
				manager.createChunkPool ();

				clientRenderer = gameObject.GetComponent ("VoxelModifyTerrain") as VoxelModifyTerrain;
				clientRenderer.setStartRegion (centerRegion);


				InvokeRepeating ("SaveToDiskEvent", 30f, 30f);
		}

		public void changeFocusRegion (Region newRegion)
		{
				//Load up region neighbors. Create a new regions as needed.
				//loadAllNeighbors (newRegion, true);  


		}

		/**
	 * Gets the region at the specified indices in the Dictionary
	 * 
	 **/
		public Region getRegionAtIndex (int x, int y, int z)
		{
				string key = x + "x" + y + "x" + z;
				if (regions.ContainsKey (key)) {
						return regions [key];
				} else {
						return null;
				}
		
		}
	
		/**
	 * Gets the region containing the specified world cordinates
	 * 
	 **/
		public Region getRegionAtCoords (int x, int y, int z)
		{
				XYZ coords = getIndexFromCoords (x, y, z);
				Region region = getRegionAtIndex (coords.x, coords.y, coords.z);
				if (region == null) {
						region = createRegion (coords.x, coords.y, coords.z, false);
				}
				return region;
				
		}
		
		public XYZ getIndexFromCoords (int x, int y, int z)
		{
				if (x < 0) {
						x = x - regionXZ + 1;
				}
				if (z < 0) {
						z = z - regionXZ + 1;
				}
				//y will never be less than zero
		
				int regionsX = x / regionXZ;
				int regionsY = y / regionY;
				int regionsZ = z / regionXZ;
				
				XYZ xyz = new XYZ ();
				xyz.x = regionsX;
				xyz.y = regionsY;
				xyz.z = regionsZ;
				return xyz;
		}
		private void loadNeighbor (Region region, bool isAsync, int x, int y, int z)
		{
				Region neighbor = getRegionAtIndex (region.offsetX + x, region.offsetY + y, region.offsetZ + z);
				if (neighbor == null) {
						Debug.Log ("Creating neighbor at " + (region.offsetX + x) + "," + (region.offsetY + y) + "," + (region.offsetZ + z));
						neighbor = createRegion (region.offsetX + x, region.offsetY + y, region.offsetZ + z, isAsync);
				}
		
		}
		public void loadAllNeighbors (Region region, bool isAsync)
		{
				

				loadNeighbor (region, isAsync, 0, 0, 1);
				loadNeighbor (region, isAsync, 0, 0, -1);
				loadNeighbor (region, isAsync, 1, 0, 0);
				loadNeighbor (region, isAsync, -1, 0, 0);
				loadNeighbor (region, isAsync, -1, 0, 1);
				loadNeighbor (region, isAsync, 1, 0, -1);
				loadNeighbor (region, isAsync, 1, 0, 1);
				loadNeighbor (region, isAsync, -1, 0, -1);
				
				loadNeighbor (region, isAsync, 0, 1, 1);
				loadNeighbor (region, isAsync, 0, 1, -1);
				loadNeighbor (region, isAsync, 1, 1, 0);
				loadNeighbor (region, isAsync, -1, 1, 0);
				loadNeighbor (region, isAsync, -1, 1, 1);
				loadNeighbor (region, isAsync, 1, 1, -1);
				loadNeighbor (region, isAsync, 1, 1, 1);
				loadNeighbor (region, isAsync, -1, 1, -1);
		
				loadNeighbor (region, isAsync, 0, -1, 1);
				loadNeighbor (region, isAsync, 0, -1, -1);
				loadNeighbor (region, isAsync, 1, -1, 0);
				loadNeighbor (region, isAsync, -1, -1, 0);
				loadNeighbor (region, isAsync, -1, -1, 1);
				loadNeighbor (region, isAsync, 1, -1, -1);
				loadNeighbor (region, isAsync, 1, -1, 1);
				loadNeighbor (region, isAsync, -1, -1, -1);


		}

		public void saveWorld ()
		{
				foreach (KeyValuePair<string,Region> kvp in regions) {
						kvp.Value.saveRegion ();
				}
		}

		public Region createRegion (int x, int y, int z, bool isAsync)
		{

				Region region = new Region ();
				region.regionXZ = this.regionXZ;
				region.regionY = this.regionY;
				region.regionXZ = this.regionXZ;
				region.offsetX = x;
				region.offsetY = y;
				region.offsetZ = z;
				regions.Add (region.hashString (), region);
				if (isAsync) {
						Thread oThread = new Thread (new ThreadStart (region.create));
						oThread.Start ();
				} else {
						Debug.LogWarning ("**Non-async region create called**");
						region.create ();
				}
				
				
				return region;
		}

		private void SaveToDiskEvent ()
		{
				if (useDisk) {
						foreach (KeyValuePair<string,Region> kvp in regions) {
								//TODO: Possible ConcurrentModification here.
								if (kvp.Value.isDirty) {
										Thread oThread = new Thread (new ThreadStart (kvp.Value.saveRegion));
										oThread.Start ();
								}
						}
				}
			
		}

}