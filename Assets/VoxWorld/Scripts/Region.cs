//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;

public class Region : MonoBehaviour
{
		public GameObject chunk;
		public VoxelWorld world;
		public Chunk[,,] chunks;
		public int chunkSize = 16;
		public byte[,,] data;
		public  int regionX = 32;
		public   int regionY = 32;
		public  int regionZ = 32;
		public int offsetX;
		public int offsetZ;
		//public Region north, south, east, west, northWest, northEast, southWest, southEast = null;
		public float distToLoad;
		public float distToUnload;
//		public Region[,] neighbors;
//		public enum Directions
//		{
//				North,
//				South,
//				East,
//				West,
//				NorthWest,
//				NorthEast,
//				SouthWest,
//				SouthEast}
//		;

		public int getBlockOffsetX ()
		{
				return offsetX * regionX;
		}

		public int getBlockOffsetZ ()
		{
				return offsetZ * regionZ;
		}

		public void createRegionData ()
		{
				//create this region's terrain data.
				data = new byte[regionX, regionY, regionZ];
				createPerlin ();
				chunks = new Chunk[Mathf.FloorToInt (regionX / chunkSize),
		                   Mathf.FloorToInt (regionY / chunkSize),
		                   Mathf.FloorToInt (regionZ / chunkSize)];


		}

		private void createFlatBiome ()
		{
				for (int x=0; x<regionX; x++) {
						for (int z=0; z<regionZ; z++) {
								for (int y=0; y<regionY; y++) {
										if (y <= (regionY / 2)) {
												data [x, y, z] = 1;
										}
								}
						}
				}	
		}
	
		private void createPerlin ()
		{
				for (int x=0; x<regionX; x++) {
						for (int z=0; z<regionZ; z++) {
								int stone = PerlinNoise (this.getBlockOffsetX () + x, 0, this.getBlockOffsetZ () + z, 100, 20, 1.2f);
								stone += PerlinNoise (this.getBlockOffsetX () + x, 700, this.getBlockOffsetZ () + z, 20, 4, 0) + 10;
								int dirt = PerlinNoise (this.getBlockOffsetX () + x, 100, this.getBlockOffsetZ () + z, 50, 2, 0);
				
								for (int y=0; y<regionY; y++) {
										if (y <= stone) {
												data [x, y, z] = 1;
										} else if (y <= dirt + stone) { //Changed this line thanks to a comment
												data [x, y, z] = 2;
										}
					
								}
						}
				}
		}
	
		public void GenColumn (int x, int z)
		{
				for (int y=0; y<chunks.GetLength(1); y++) {
			
						//Create a temporary Gameobject for the new chunk instead of using chunks[x,y,z]
						GameObject newChunk = Instantiate (chunk,
			                                   new Vector3 (x * chunkSize - 0.5f + getBlockOffsetX (),
			             y * chunkSize + 0.5f,
			             z * chunkSize - 0.5f + getBlockOffsetZ ()),
			                                   new Quaternion (0, 0, 0, 0)) as GameObject;
				
						newChunk.transform.parent = this.transform;
						//Now instead of using a temporary variable for the script assign it
						//to chunks[x,y,z] and use it instead of the old \"newChunkScript\"
						chunks [x, y, z] = newChunk.GetComponent ("Chunk") as Chunk;
						chunks [x, y, z].regionGO = gameObject;
						chunks [x, y, z].chunkSize = chunkSize;
						chunks [x, y, z].chunkX = x * chunkSize;
						chunks [x, y, z].chunkY = y * chunkSize;
						chunks [x, y, z].chunkZ = z * chunkSize;
			
				}
		}
	
		public void UnloadColumn (int x, int z)
		{
				for (int y=0; y<chunks.GetLength(1); y++) {
						GameObject.Destroy (chunks [x, y, z].gameObject);
			
				}
		}
	
		int PerlinNoise (float x, int y, float z, float scale, float height, float power)
		{
				float rValue;
				rValue = Noise.GetNoise (((double)x) / scale, ((double)y) / scale, ((double)z) / scale);
				rValue *= height;
		
				if (power != 0) {
						rValue = Mathf.Pow (rValue, power);
				}
		
				return (int)rValue;
		}

		public byte Block (int x, int y, int z)
		{
		
				if (x >= regionX || x < 0 || y >= regionY || y < 0 || z >= regionZ || z < 0) {
						int worldX = x + this.getBlockOffsetX();
						int worldZ = z + this.getBlockOffsetZ();
						Region neighbor = world.getRegionAtCoords(worldX,worldZ);
						int[] normalizedCoords = normalizeToLocal (x, y, z);
						return neighbor.Block (normalizedCoords);
				} else {
						return data [x, y, z];
				}
		}
		
		private byte Block (int[] normalizedCoords)
		{
				byte block = data [normalizedCoords [0], normalizedCoords [1], normalizedCoords [2]];
				return block;

		}

		private int[] normalizeToLocal (int x, int y, int z)
		{
				int[] result = {x,y,z};
				if (x >= regionX) {
						result [0] = x - regionX;
				} else if (x < 0) {
						result [0] = x + regionX;
				}

				if (z >= regionZ) {
						result [2] = z - regionZ;
				} else if (z < 0) {
						result [2] = z + regionZ;
				}
				if (y >= regionY) {
						result [1] = regionY - 1;
				} else if (y < 0) {
						result [1] = 0;
				}

				result[0] = result[0] % regionX;
				return result;
		}

		public  int[] convertWorldToLocal (int x, int y, int z)
		{
				int[] result = {x,y,z};
				
				if (x < 0) {
						result [0] = x - getBlockOffsetX ();
				} else {
						result [0] = x % regionX;
				}

				result [1] = y;

				if (z < 0) {
						result [2] = z - getBlockOffsetZ ();
				} else {
						result [2] = z % regionZ;
				}
				return result;
		}

		public void flagChunkForUpdate (int x, int y, int z)
		{

				int chunkDim = regionX / chunkSize;
				if (x >= chunkDim) {
						world.getRegionAtIndex (this.offsetX+1,this.offsetZ).chunks [x - chunkDim, y, z].update = true;
				} else if (x < 0) {
						world.getRegionAtIndex (this.offsetX-1,this.offsetZ).chunks [x + chunkDim, y, z].update = true;
				} else if (z >= chunkDim) {
						world.getRegionAtIndex (this.offsetX, this.offsetZ+1).chunks [x, y, z - chunkDim].update = true;
				} else if (z < 0) {
						world.getRegionAtIndex (this.offsetX, this.offsetZ-1).chunks [x, y, z + chunkDim].update = true;
				}else{
						chunks[x,y,z].update = true;
				}

		}

		public string hashString ()
		{
				return this.offsetX + "|" + this.offsetZ;
		}
}


