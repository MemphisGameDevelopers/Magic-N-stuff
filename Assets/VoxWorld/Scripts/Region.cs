//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;

public class Region : MonoBehaviour
{
		public GameObject chunk;
		public GameObject tree;
		public Chunk[,,] chunks;
		public ItemChunk[,,] itemChunks;
		public int chunkSize = 16;
		public byte[,,] data;
		public  int regionXZ = 32;
		public   int regionY = 32;
		public int offsetX;
		public int offsetZ;
		public float distToLoad;
		public float distToUnload;
		public bool isDirty;
		private static VoxelWorld world;

		public static void setWorld (VoxelWorld w)
		{
				world = w;
		}

		public int getBlockOffsetX ()
		{
				return offsetX * regionXZ;
		}

		public int getBlockOffsetZ ()
		{
				return offsetZ * regionXZ;
		}

		public void saveRegion ()
		{
				try {
						if (!Directory.Exists ("C:/Data/")) {
								Directory.CreateDirectory ("C:/Data/");
						}
						string fileNamePath = "C:/Data/" + this.hashString () + ".dat";
						print ("Saving to " + fileNamePath);
						FileStream fs = File.Create (fileNamePath);
						BinaryWriter writer = new BinaryWriter (fs);
						for (int x=0; x<regionXZ; x++) {
								for (int z=0; z<regionXZ; z++) {
										for (int y=0; y<regionY; y++) {
												writer.Write (data [x, y, z]);
										}
								}
						}	
						isDirty = false;
						writer.Close ();
				} catch (Exception ex) {
						Debug.Log (ex.ToString ());
				}
		}

		public void createRegionData ()
		{
				data = new byte[regionXZ, regionY, regionXZ];
				chunks = new Chunk[Mathf.FloorToInt (regionXZ / chunkSize),
		                  Mathf.FloorToInt (regionY / chunkSize),
		                  Mathf.FloorToInt (regionXZ / chunkSize)];
				itemChunks = new ItemChunk[Mathf.FloorToInt (regionXZ / chunkSize),
		                   Mathf.FloorToInt (regionY / chunkSize),
		                   Mathf.FloorToInt (regionXZ / chunkSize)];

				
				try {
						string fileNamePath = "C:/Data/" + this.hashString () + ".dat";

						if (File.Exists (fileNamePath)) {
								//Load in data from file if found
								FileStream fs = File.OpenRead (fileNamePath);
								BinaryReader reader = new BinaryReader (fs);
								for (int x=0; x<regionXZ; x++) {
										for (int z=0; z<regionXZ; z++) {
												for (int y=0; y<regionY; y++) {
														data [x, y, z] = reader.ReadByte ();
												}
										}
								}	
								reader.Close ();
						} else {
								//create this region's terrain data.
								createFlatBiome ();
								//merge (dungeon.tiles, data);


						}
				} catch (Exception ex) {
						Debug.Log (ex.ToString ());
				}

				//create Trees
				createTrees ();
		}

		private void merge (int[,,] source, int[,,] destination)
		{
		
				for (int x = 0; x < source.GetLength(0); x++) {
						for (int y = 0; y < source.GetLength(1); y++) {
								for (int z = 0; z < source.GetLength(2); z++) {
										destination [x, y, z] = source [x, y, z];
								}
						}
				}
		}
		private void createTrees ()
		{
				LinkedList<Vector3> trees = TreePlanter.generateTrees (world, this);
				foreach (Vector3 position in trees) {
						int x = ((int)position.x / chunkSize);
						int y = ((int)position.y / chunkSize);
						int z = ((int)position.z / chunkSize);
					
						if (itemChunks [x, y, z] == null) {
								ItemChunk itemChunk = new ItemChunk ();
								itemChunks [x, y, z] = itemChunk;
						}
						itemChunks [x, y, z].addItem (position);
				}



		}
	
		private void createFlatBiome ()
		{
				for (int x=0; x<regionXZ; x++) {
						for (int z=0; z<regionXZ; z++) {
								for (int y=0; y<regionY; y++) {
										if (y <= (regionY / 2)) {
												data [x, y, z] = 1;
										}
								}
						}
				}	
		}
	
		private void createPerlin ()
		{
				for (int x=0; x<regionXZ; x++) {
						for (int z=0; z<regionXZ; z++) {
								int stone = PerlinNoise (this.getBlockOffsetX () + x, 0, this.getBlockOffsetZ () + z, 100, 20, 1.2f);
								stone += PerlinNoise (this.getBlockOffsetX () + x, 700, this.getBlockOffsetZ () + z, 20, 4, 0) + 10;
								int dirt = PerlinNoise (this.getBlockOffsetX () + x, 100, this.getBlockOffsetZ () + z, 50, 2, 0);
				
								for (int y=0; y<regionY; y++) {
										if (y <= stone) {
												data [x, y, z] = 1;
										} else if (y <= dirt + stone) { //Changed this line thanks to a comment
												data [x, y, z] = 2;
										}
					
								}
						}
				}
		}
	
		public void GenColumn (int x, int z)
		{
				for (int y=0; y<chunks.GetLength(1); y++) {
			
						//Create a temporary Gameobject for the new chunk instead of using chunks[x,y,z]
						GameObject newChunk = Instantiate (chunk,
			                                   new Vector3 (x * chunkSize - 0.5f + getBlockOffsetX (),
			             y * chunkSize + 0.5f,
			             z * chunkSize - 0.5f + getBlockOffsetZ ()),
			                                   new Quaternion (0, 0, 0, 0)) as GameObject;
				
						newChunk.transform.parent = this.transform;
						chunks [x, y, z] = newChunk.GetComponent ("Chunk") as Chunk;
						chunks [x, y, z].regionGO = gameObject;
						chunks [x, y, z].chunkSize = chunkSize;
						chunks [x, y, z].chunkX = x * chunkSize;
						chunks [x, y, z].chunkY = y * chunkSize;
						chunks [x, y, z].chunkZ = z * chunkSize;
						if (itemChunks [x, y, z] != null) {
								chunks [x, y, z].itemChunk = itemChunks [x, y, z];
						}
						
			
				}
		}
	
		public void UnloadColumn (int x, int z)
		{
				for (int y=0; y<chunks.GetLength(1); y++) {
						GameObject.Destroy (chunks [x, y, z].gameObject);
			
				}
		}
	
		int PerlinNoise (float x, int y, float z, float scale, float height, float power)
		{
				float rValue;
				rValue = Noise.GetNoise (((double)x) / scale, ((double)y) / scale, ((double)z) / scale);
				rValue *= height;
		
				if (power != 0) {
						rValue = Mathf.Pow (rValue, power);
				}
		
				return (int)rValue;
		}

		public byte Block (int x, int y, int z)
		{
		
				if (x >= regionXZ || x < 0 || y >= regionY || y < 0 || z >= regionXZ || z < 0) {
						int worldX = x + this.getBlockOffsetX ();
						int worldZ = z + this.getBlockOffsetZ ();
						Region neighbor = world.getRegionAtCoords (worldX, worldZ);
						int[] normalizedCoords = normalizeToLocal (x, y, z);
						return neighbor.Block (normalizedCoords);
				} else {
						return data [x, y, z];
				}
		}
		
		private byte Block (int[] normalizedCoords)
		{
				byte block = data [normalizedCoords [0], normalizedCoords [1], normalizedCoords [2]];
				return block;

		}

		private int[] normalizeToLocal (int x, int y, int z)
		{
				int[] result = {x,y,z};
				if (x >= regionXZ) {
						result [0] = x - regionXZ;
				} else if (x < 0) {
						result [0] = x + regionXZ;
				}

				if (z >= regionXZ) {
						result [2] = z - regionXZ;
				} else if (z < 0) {
						result [2] = z + regionXZ;
				}
				if (y >= regionY) {
						result [1] = regionY - 1;
				} else if (y < 0) {
						result [1] = 0;
				}

				result [0] = result [0] % regionXZ;
				return result;
		}

		public  int[] convertWorldToLocal (int x, int y, int z)
		{
				int[] result = {x,y,z};
				
				if (x < 0) {
						result [0] = x - getBlockOffsetX ();
				} else {
						result [0] = x % regionXZ;
				}

				result [1] = y;

				if (z < 0) {
						result [2] = z - getBlockOffsetZ ();
				} else {
						result [2] = z % regionXZ;
				}
				return result;
		}

		public void flagChunkForUpdate (int x, int y, int z)
		{

				int chunkDim = regionXZ / chunkSize;
				if (x >= chunkDim) {
						world.getRegionAtIndex (this.offsetX + 1, this.offsetZ).chunks [x - chunkDim, y, z].update = true;
				} else if (x < 0) {
						world.getRegionAtIndex (this.offsetX - 1, this.offsetZ).chunks [x + chunkDim, y, z].update = true;
				} else if (z >= chunkDim) {
						world.getRegionAtIndex (this.offsetX, this.offsetZ + 1).chunks [x, y, z - chunkDim].update = true;
				} else if (z < 0) {
						world.getRegionAtIndex (this.offsetX, this.offsetZ - 1).chunks [x, y, z + chunkDim].update = true;
				} else {
						chunks [x, y, z].update = true;
				}

		}

		public string hashString ()
		{
				return this.offsetX + "x" + this.offsetZ;
		}
}


