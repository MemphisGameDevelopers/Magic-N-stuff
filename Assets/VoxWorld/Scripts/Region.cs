//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;

public class Region : MonoBehaviour, VoxelStream
{
		public GameObject chunk;
		public GameObject tree;
		public Chunk[,,] chunks;
		//public ItemChunk[,,] itemChunks;
		public byte[,,] data;
		public  int regionXZ = 32;
		public   int regionY = 32;
		public int offsetX;
		public int offsetY;
		public int offsetZ;
		public bool isDirty;
		private bool isJustAir = true;
		private bool isJustSolid = true;
		public static ChunkManager chunkManager;
		private static VoxelWorld world;


		void Start ()
		{
				if (chunkManager == null) {
						GameObject chunkManagerGO = GameObject.Find ("Chunk Manager");
						chunkManager = chunkManagerGO.GetComponent<ChunkManager> ();
				}
		}
		public static void setWorld (VoxelWorld w)
		{
				world = w;
		}

		public int getBlockOffsetX ()
		{
				return offsetX * regionXZ;
		}
		
		public int getBlockOffsetY ()
		{
				return offsetY * regionY;
		}
		public int getBlockOffsetZ ()
		{
				return offsetZ * regionXZ;
		}

		public void saveRegion ()
		{
				try {
						if (!Directory.Exists ("C:/Data/")) {
								Directory.CreateDirectory ("C:/Data/");
						}
						string fileNamePath = "C:/Data/" + this.hashString () + ".dat";
						print ("Saving to " + fileNamePath);
						FileStream fs = File.Create (fileNamePath);
						BinaryWriter writer = new BinaryWriter (fs);
						for (int x=0; x<regionXZ; x++) {
								for (int z=0; z<regionXZ; z++) {
										for (int y=0; y<regionY; y++) {
												writer.Write (data [x, y, z]);
										}
								}
						}	
						isDirty = false;
						writer.Close ();
				} catch (Exception ex) {
						Debug.Log (ex.ToString ());
				}
		}

		public void create ()
		{
	
				//Debug.Log ("Creating new region.");
				data = new byte[regionXZ, regionY, regionXZ];
				chunks = new Chunk[Mathf.FloorToInt (regionXZ / Chunk.chunkSize),
		                  Mathf.FloorToInt (regionY / Chunk.chunkSize),
		                   Mathf.FloorToInt (regionXZ / Chunk.chunkSize)];
//				itemChunks = new ItemChunk[Mathf.FloorToInt (regionXZ / Chunk.chunkSize),
//		                           Mathf.FloorToInt (regionY / Chunk.chunkSize),
//		                           Mathf.FloorToInt (regionXZ / Chunk.chunkSize)];

				
				try {
						string fileNamePath = "C:/Data/" + this.hashString () + ".dat";

						if (File.Exists (fileNamePath) && world.useDisk) {
								//Load in data from file if found
								FileStream fs = File.OpenRead (fileNamePath);
								BinaryReader reader = new BinaryReader (fs);
								for (int x=0; x<regionXZ; x++) {
										for (int z=0; z<regionXZ; z++) {
												for (int y=0; y<regionY; y++) {
														data [x, y, z] = reader.ReadByte ();
												}
										}
								}	
								reader.Close ();
						} else {
								//create this region's terrain data.
								WorldGeneration.Instance.createPerlin (data, getBlockOffsetX (), getBlockOffsetY (), getBlockOffsetZ ());
								//WorldGeneration.Instance.createFlatBiome (data);
								isDirty = true;
								//createPerlin ();
								
								//Create a dungeon and put it in the scene.
//								GameObject dungeonGO = Instantiate (Resources.Load ("Voxel Generators/Dungeon Generator")) as GameObject;
//								VoxelStream dungeon = dungeonGO.GetComponent (typeof(VoxelStream)) as VoxelStream;
//								dungeon.create ();
//								merge (dungeon, this);

								//Aggregation flags
								for (int x=0; x<regionXZ; x++) {
										for (int z=0; z<regionXZ; z++) {
												for (int y=0; y<regionY; y++) {
														if (data [x, y, z] != 0) {
																isJustAir = false;
														} else {
																isJustSolid = false;
														}
												}
										}
								}
						}
				} catch (Exception ex) {
						Debug.Log (ex.ToString ());
				}

				//create Trees
				//createTrees ();
		}

		private void merge (VoxelStream source, VoxelStream destination)
		{
				byte[,,] sourceData = source.GetAllBlocks ();
				byte[,,] destData = destination.GetAllBlocks ();
				for (int x = 0; x < sourceData.GetLength(0); x++) {
						for (int y = 0; y < sourceData.GetLength(1); y++) {
								for (int z = 0; z < sourceData.GetLength(2); z++) {
										destData [x, 32 + y, z] = sourceData [x, y, z];
								}
						}
				}
		}

		private bool isChunkJustAir (int xBlock, int yBlock, int zBlock)
		{
				if (data [xBlock, yBlock, zBlock] == 0) {
						for (int xi = xBlock; xi < xBlock + Chunk.chunkSize; xi++) {
								for (int yi = yBlock; yi < yBlock + Chunk.chunkSize; yi++) {
										for (int zi = zBlock; zi < zBlock + Chunk.chunkSize; zi++) {
												if (data [xi, yi, zi] != 0) {
														return false;
												}
										}
								}
						}
						return true;
				} else {
						return false;
				}
				
		}
		
		//TODO This method only check region interrior chunks.	
		private bool isSolidChunkAndEncased (int xBlock, int yBlock, int zBlock)
		{
				if (data [xBlock, yBlock, zBlock] == 1) {
						int xStart = xBlock - 1;
						int yStart = yBlock - 1;
						int zStart = zBlock - 1;
						int xFinish = xBlock + Chunk.chunkSize + 1;
						int yFinish = yBlock + Chunk.chunkSize + 1;
						int zFinish = zBlock + Chunk.chunkSize + 1;
		
						//Cant test boundry chunks yet
						if (xStart < 0 || yStart < 0 || zStart < 0 || xFinish >= regionXZ || yFinish >= regionY || zFinish >= regionXZ) {
								//Debug.Log ("Chunk is boundry. Creating");
								return false;
						}
				
				
						for (int xi = xStart; xi < xFinish; xi++) {
								for (int yi = yStart; yi < yFinish; yi++) {
										for (int zi = zStart; zi < zFinish; zi++) {
												if (data [xi, yi, zi] == 0) {
														//Debug.Log ("Chunk has air. Creating");
														return false;
												}
										}
								}
						}
						return true;
				} else {
						return false;
				}
				
		}

//		private void createTrees ()
//		{
//				LinkedList<Vector3> trees = TreePlanter.generateTrees (world, this);
//				foreach (Vector3 position in trees) {
//						int x = ((int)position.x / Chunk.chunkSize);
//						int y = ((int)position.y / Chunk.chunkSize);
//						int z = ((int)position.z / Chunk.chunkSize);
//					
//						if (itemChunks [x, y, z] == null) {
//								ItemChunk itemChunk = new ItemChunk ();
//								itemChunks [x, y, z] = itemChunk;
//						}
//						itemChunks [x, y, z].addItem (position);
//				}
//
//
//
//		}
	
		public void loadChunk (int x, int y, int z)
		{
				//print (x + "," + y + "," + z);
				if (chunks [x, y, z] == null) {
						int xBlock = x * Chunk.chunkSize;
						int yBlock = y * Chunk.chunkSize;
						int zBlock = z * Chunk.chunkSize;
			
						//Don't generate chunks of air or solid enclosed rock unless it's at y = 0.
						if (isChunkJustAir (xBlock, yBlock, zBlock) ||
								isSolidChunkAndEncased (xBlock, yBlock, zBlock)) {
								if (y != 0)
										return;
						}
			
			
						GameObject newChunk = chunkManager.getChunk ();
			
						newChunk.transform.position = new Vector3 (xBlock - 0.5f + getBlockOffsetX (),
			                                           yBlock + 0.5f, zBlock - 0.5f + getBlockOffsetZ ());
						chunks [x, y, z] = newChunk.GetComponent ("Chunk") as Chunk;
						newChunk.transform.parent = this.transform;
						chunks [x, y, z].setVoxelsToRender (this);
						chunks [x, y, z].chunkX = xBlock;
						chunks [x, y, z].chunkY = yBlock;
						chunks [x, y, z].chunkZ = zBlock;

						//						if (itemChunks [x, y, z] != null) {
						//								ItemChunk itemChunk = itemChunks [x, y, z];
						//								//itemChunk.addItem (chunks[x,y,z], this, 
						//								//TODO Re-enable rending item chunks.
						//						}
			
						//Chunk manager will handle updating the chunk
						chunkManager.flagChunkForUpdate (chunks [x, y, z]);
				}
	
		}
		
		public void unloadChunk (int x, int y, int z)
		{
				if (chunks [x, y, z] != null) {
						//chunks [x, y, z].clearMesh ();
						chunkManager.freeChunk (chunks [x, y, z].gameObject);
						chunks [x, y, z] = null;
				}
		
		}
//		public void GenColumn (int x, int z)
//		{
//				for (int y=0; y<chunks.GetLength(1); y++) {
//						if (chunks [x, y, z] == null) {
//								int xBlock = x * Chunk.chunkSize;
//								int yBlock = y * Chunk.chunkSize;
//								int zBlock = z * Chunk.chunkSize;
//			
//								//Don't generate chunks of air.
//								if (isChunkJustAir (xBlock, yBlock, zBlock) ||
//										isSolidChunkAndEncased (xBlock, yBlock, zBlock)) {
//										continue;
//								}
//								
//								
//								GameObject newChunk = chunkManager.getChunk ();
//						
//								newChunk.transform.position = new Vector3 (xBlock - 0.5f + getBlockOffsetX (),
//										yBlock + 0.5f, zBlock - 0.5f + getBlockOffsetZ ());
//								chunks [x, y, z] = newChunk.GetComponent ("Chunk") as Chunk;
//								newChunk.transform.parent = this.transform;
//								chunks [x, y, z].setVoxelsToRender (this);
//								chunks [x, y, z].chunkX = xBlock;
//								chunks [x, y, z].chunkY = yBlock;
//								chunks [x, y, z].chunkZ = zBlock;
//
//								//chunks [x, y, z].update = true;
////						if (itemChunks [x, y, z] != null) {
////								ItemChunk itemChunk = itemChunks [x, y, z];
////								//itemChunk.addItem (chunks[x,y,z], this, 
////								//TODO Re-enable rending item chunks.
////						}
//						
//								//Chunk manager will handle updating the chunk
//								chunkManager.flagChunkForUpdate (chunks [x, y, z]);
//						}
//			
//				}
//		}
//	
//		public void UnloadColumn (int x, int z)
//		{
//				for (int y=0; y<chunks.GetLength(1); y++) {
//						if (chunks [x, y, z] != null) {
//								chunks [x, y, z].clearMesh ();
//								chunkManager.freeChunk (chunks [x, y, z].gameObject);
//								chunks [x, y, z] = null;
//						}
//				}
//		}

		public Vector3 getBounds ()
		{
				return new Vector3 (data.GetLength (0), data.GetLength (1), data.GetLength (2));
		}
		public byte[,,] GetAllBlocks ()
		{
				return data;
		}
		public byte GetBlockAtRelativeCoords (int x, int y, int z)
		{
		
				if (x >= regionXZ || x < 0 || y >= regionY || y < 0 || z >= regionXZ || z < 0) {
						int worldX = x + this.getBlockOffsetX ();
						int worldY = y + this.getBlockOffsetY ();
						int worldZ = z + this.getBlockOffsetZ ();
						
						//Disregard negative heights.  
						if (worldY < 0) {
								worldY = 0;
						}
						Region neighbor = world.getRegionAtCoords (worldX, worldY, worldZ);
						int[] normalizedCoords = normalizeToLocal (x, y, z);
						return neighbor.GetBlockAtRelativeCoords (normalizedCoords);
				} else {
						return data [x, y, z];
				}
		}
		
		private byte GetBlockAtRelativeCoords (int[] normalizedCoords)
		{
				byte block = data [normalizedCoords [0], normalizedCoords [1], normalizedCoords [2]];
				return block;

		}

		private int[] normalizeToLocal (int x, int y, int z)
		{
				int[] result = {x,y,z};
				if (x >= regionXZ) {
						result [0] = x - regionXZ;
				} else if (x < 0) {
						result [0] = x + regionXZ;
				}
				
				if (y >= regionY) {
						result [1] = y - regionY;
				} else if (y < 0) {
						result [1] = y + regionY;
				}
				
				if (z >= regionXZ) {
						result [2] = z - regionXZ;
				} else if (z < 0) {
						result [2] = z + regionXZ;
				}


				result [0] = result [0] % regionXZ;
				return result;
		}

		public  int[] convertWorldToLocal (int x, int y, int z)
		{
				int[] result = {x,y,z};
				
				if (x < 0) {
						result [0] = x - getBlockOffsetX ();
				} else {
						result [0] = x % regionXZ;
				}

				result [1] = y;

				if (z < 0) {
						result [2] = z - getBlockOffsetZ ();
				} else {
						result [2] = z % regionXZ;
				}
				return result;
		}

		public void flagChunkForUpdate (int x, int y, int z)
		{

				int chunkDim = regionXZ / Chunk.chunkSize;
				if (x >= chunkDim) {
						world.getRegionAtIndex (this.offsetX + 1, this.offsetY, this.offsetZ).chunks [x - chunkDim, y, z].update = true;
				} else if (x < 0) {
						world.getRegionAtIndex (this.offsetX - 1, this.offsetY, this.offsetZ).chunks [x + chunkDim, y, z].update = true;
				} else if (z >= chunkDim) {
						world.getRegionAtIndex (this.offsetX, this.offsetY, this.offsetZ + 1).chunks [x, y, z - chunkDim].update = true;
				} else if (z < 0) {
						world.getRegionAtIndex (this.offsetX, this.offsetY, this.offsetZ - 1).chunks [x, y, z + chunkDim].update = true;
				} else {
						chunkManager.flagChunkForUpdate (chunks [x, y, z]);
				}

		}

		public string hashString ()
		{
				return this.offsetX + "x" + this.offsetY + "x" + this.offsetZ;
		}
}


