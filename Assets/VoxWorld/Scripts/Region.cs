//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34003
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;

public class Region : MonoBehaviour
{
		public GameObject chunk;
		public Chunk[,,] chunks;
		public int chunkSize = 16;
		public byte[,,] data;
		public int regionX = 32;
		public int regionY = 32;
		public int regionZ = 32;
		public int regionXoffset;
		public int regionZoffset;
		public Region north, south, east, west, northWest, northEast, southWest, southEast = null;
		public float distToLoad;
		public float distToUnload;
		public enum Directions
		{
				North,
				South,
				East,
				West,
				NorthWest,
				NorthEast,
				SouthWest,
				SouthEast}
		;

		void Start ()
		{

		}
	
		public Region getNeighbor (Directions direction)
		{
				Region result = null;
				switch (direction) {
			
				case Directions.North:
						result = north;
						break;
				case Directions.South:
						result = south;
						break;
				case Directions.East:
						result = east;
						break;
				case Directions.West:
						result = west;
						break;
				case Directions.NorthWest:
						result = northWest;
						break;
				case Directions.SouthWest:
						result = southWest;
						break;
				case Directions.NorthEast:
						result = northEast;
						break;
				case Directions.SouthEast:
						result = southEast;
						break;
				}


				if(result == null){

				}

				return result;
		}

		public void setNeighbor (Region neighbor, Directions direction)
		{
				if(neighbor == null){
					return;
				}
				//Set the link back to the neighbor.
				switch (direction) {
				
				case Directions.North:
						this.north = neighbor;
						if (neighbor.south == null) {
								neighbor.setNeighbor (this, Directions.South);
						}
						break;
				case Directions.South:
						this.south = neighbor;
						if (neighbor.north == null) {
								neighbor.setNeighbor (this, Directions.North);
						}
						break;
				case Directions.East:
						this.east = neighbor;
						if (neighbor.west == null) {
								neighbor.setNeighbor (this, Directions.West);
						}
						break;
				case Directions.West:
						this.west = neighbor;
						if (neighbor.east == null) {
								neighbor.setNeighbor (this, Directions.East);
						}
						break;
				case Directions.NorthEast:
						this.northEast = neighbor;
						if (neighbor.southWest == null) {
								neighbor.setNeighbor (this, Directions.SouthWest);
						}
						break;
				case Directions.NorthWest:
						this.northWest = neighbor;
						if (neighbor.southEast == null) {
								neighbor.setNeighbor (this, Directions.SouthEast);
						}
						break;
				case Directions.SouthEast:
						this.southEast = neighbor;
						if (neighbor.northWest == null) {
								neighbor.setNeighbor (this, Directions.NorthWest);
						}
						break;
				case Directions.SouthWest:
						this.southWest = neighbor;
						if (neighbor.northEast == null) {
								neighbor.setNeighbor (this, Directions.NorthEast);
						}
						break;
				}

		}

		public void createRegionData ()
		{
		
				//create this region's terrain data.
				data = new byte[regionX, regionY, regionZ];
		
				createPerlin ();
		
				chunks = new Chunk[Mathf.FloorToInt (regionX / chunkSize),
		                   Mathf.FloorToInt (regionY / chunkSize),
		                   Mathf.FloorToInt (regionZ / chunkSize)];
		}

		private void createFlatBiome ()
		{
				for (int x=0; x<regionX; x++) {
						for (int z=0; z<regionZ; z++) {
								for (int y=0; y<regionY; y++) {
										if (y <= (regionY / 2)) {
												data [x, y, z] = 1;
										}
								}
						}
				}	
		}
	
		private void createPerlin ()
		{
				for (int x=0; x<regionX; x++) {
						for (int z=0; z<regionZ; z++) {
								int stone = PerlinNoise (this.regionXoffset + x, 0, this.regionZoffset + z, 100, 3, 1.2f);
								stone += PerlinNoise (this.regionXoffset + x, 700, this.regionZoffset + z, 20, 4, 0) + 10;
								int dirt = PerlinNoise (this.regionXoffset + x, 100, this.regionZoffset + z, 50, 2, 0);
				
								for (int y=0; y<regionY; y++) {
										if (y <= stone) {
												data [x, y, z] = 1;
										} else if (y <= dirt + stone) { //Changed this line thanks to a comment
												data [x, y, z] = 2;
										}
					
								}
						}
				}
		}
	
		public void GenColumn (int x, int z)
		{
				for (int y=0; y<chunks.GetLength(1); y++) {
			
						//Create a temporary Gameobject for the new chunk instead of using chunks[x,y,z]
						GameObject newChunk = Instantiate (chunk,
			                                   new Vector3 (x * chunkSize - 0.5f + regionXoffset,
			             y * chunkSize + 0.5f,
			             z * chunkSize - 0.5f + regionZoffset),
			                                   new Quaternion (0, 0, 0, 0)) as GameObject;
						newChunk.transform.parent = this.transform;
						//Now instead of using a temporary variable for the script assign it
						//to chunks[x,y,z] and use it instead of the old \"newChunkScript\"
						chunks [x, y, z] = newChunk.GetComponent ("Chunk") as Chunk;
						chunks [x, y, z].regionGO = gameObject;
						chunks [x, y, z].chunkSize = chunkSize;
						chunks [x, y, z].chunkX = x * chunkSize;
						chunks [x, y, z].chunkY = y * chunkSize;
						chunks [x, y, z].chunkZ = z * chunkSize;
			
				}
		}
	
		public void UnloadColumn (int x, int z)
		{
				for (int y=0; y<chunks.GetLength(1); y++) {
						Object.Destroy (chunks [x, y, z].gameObject);
			
				}
		}
	
		int PerlinNoise (float x, int y, float z, float scale, float height, float power)
		{
				float rValue;
				rValue = Noise.GetNoise (((double)x) / scale, ((double)y) / scale, ((double)z) / scale);
				rValue *= height;
		
				if (power != 0) {
						rValue = Mathf.Pow (rValue, power);
				}
		
				return (int)rValue;
		}
	
		public byte Block (int x, int y, int z)
		{
		
				if (x >= regionX || x < 0 || y >= regionY || y < 0 || z >= regionZ || z < 0) {
						return (byte)1;
				}
		
				return data [x, y, z];
		}

		public string hashString()
	{
		Debug.Log ("x:"+regionXoffset+" z:"+regionZoffset);
		return this.regionXoffset +"|"+this.regionZoffset;
	}
}


